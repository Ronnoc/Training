**1 翻硬币游戏**
>所翻动的硬币中，最右边那个硬币的必须是从正面翻到反面,谁不能翻谁输

	局面的SG 值为局面中每个正面朝上的棋子单一存在时的SG 值的异或和
>每次能翻转一个或两个硬币。(不用连续)

	每个硬币的SG值为它的编号，初始编号为0
>每次必须连续翻转k个硬币

	sg的形式为000…01 000…01，其中一小段0的个数为k-1
>每次必须翻动两个硬币，而且这两个硬币的距离要在可行集S={1,2,3}中，硬币序号从0开始。(Twins游戏)

	位置x,sg[x]=x%3;
>每次可以翻动一个、二个或三个硬币。（Mock Turtles游戏）
>一个非负整数为odious，当且仅当该数的二进制形式的1出现的次数是奇数，否则称作evil

	当2x为odious时，sg值是2x，当2x是evil时，sg值是2x+1

**2 anti-nim游戏**
>拿最后一个棋子的人输

	先手必胜有两种状态：
	1.如果每一个小游戏都只剩下一个石子了，SG为0。
	2.至少一堆石子>1,且SG不为0.

**3 every-SG游戏**
>多线程博弈。形象的说就是红队和蓝队每个队n个人，然后进行n个博弈，最后结束的一场博弈的胜者胜利。

	如果v是先手必胜，则f[v]=max(f[u])+1,其中u为v的后继且u为先手必败。
	否则f[v]=min(f[u])+1,u为v后继。

**4 删边游戏**
>移除一个有根图的某些边，直到没有与地板的相连的边

	Colon Principle：当树枝在一个顶点上时，用一个非树枝的杆的长度来替代，相当于他们的n异或之和。
	The Fusion Principle：任何环内的节点可以融合成一点而不会改变图的sg值。
	拥有奇数条边的环可简化为一条边，偶数条边的环可简化为一个节点
**5 Ferguson博弈**
>第一个盒子中有n枚石子，第二个盒子中有m个石子(n, m > 0),清空一个盒子中的石子，然后从另一个盒子中拿若干石子到被清空的盒子中，使得最后两个盒子都不空。当两个盒子中都只有一枚石子时，游戏结束。最后成功执行操作的玩家获胜

	(x,y)至少一偶时，先手胜；都为奇时，先手败

**6 staircase nim**
>许多硬币任意分布在楼梯上，共n阶楼梯从地面由下向上编号为0到n。游戏者在每次操作时可以将楼梯j(1<=j<=n)上的任意多但至少一个硬币移动到楼梯j-1上。游戏者轮流操作，将最后一枚硬币移至地上的人获胜。

	SG=奇数台阶的硬币数nim和

**7 N阶Nim游戏**
>有k堆石子，各包含x1,x2…xk颗石子。双方玩家轮流操作，每次操作选择其中非空的若干堆，至少一堆但不超过N堆，在这若干堆中的每堆各取走其中的若干颗石子（1颗，2颗…甚至整堆），数目可以不同，取走最后一颗石子的玩家获胜。 

	当且仅当在每一个不同的二进制位上，x1,x2…xk中在该位上1的个数是N+1的倍数时，后手方有必胜策略，否则先手必胜。

**8 Nim 积**
>验题: hdu 3404

	const int maxn = 22;
	int f[maxn][maxn];
	int nim (int x, int y);
	int _nim (int x, int y) {
		if (!x || !y) return 1 << x + y;
		int &F = f[x][y];
		if (F != -1) return F;
		int ret = 1, e = 1;
		for (int i = 0; i < 16; ++i)
			if ( ( (x ^ y) >> i) & 1) e *= 1 << (1 << i);
			else if ( (x >> i) & 1) ret = nim (ret, 3 * (1 << (1 << i)) / 2);
		return F = nim (ret, e);
	}
	int nim (int x, int y) {		//nim积调用
		if (x < 2 || y < 2) return x * y;
		int ret = 0;
		for (int i = 0; i < 16; ++i)
			if ( (x >> i) & 1)
				for (int j = 0; j < 16; ++j)
					if ( (y >> j) & 1)
						ret ^= _nim (i, j);
		return ret;
	}